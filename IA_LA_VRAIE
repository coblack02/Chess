import chess

VALEURS_PIECES = {
    'p': 100,
    'n': 320,
    'b': 330,
    'r': 500,
    'q': 900,
    'k': 20000
}

VALEURS_POSITIONS_BLANCHES = {
    'P': [
        0, 0, 0, 0, 0, 0, 0, 0,
        50, 50, 50, 50, 50, 50, 50, 50,
        10, 10, 20, 30, 30, 20, 10, 10,
        5, 5, 10, 25, 25 , 10 , 5 , 5,
        -10,-10,-20,-25,-25,-20,-10,-10,
        -25,-25,-35,-45,-45,-35,-25,-25,
        -37.5,-37.5,-47.5,-75,-75,-47.5,-37.5,-37.5,
        -50 ,-50,-50,-50,-50,-50,-50,-50
    ],

    'N': [
        -50,-40,-30,-30,-30,-30,-40,-50,
        -40,-20,0,0,0,0,-20,-40,    
        -30,0,10,15,15,10,0,-30,
        -30,5,15,20,20,15,5,-30,
        -30,0,15,20,20,15,0,-30,
        -30,5,10,15,15,10,5,-30,
        -40,-20,0,5,5,0,-20,-40,
        -50,-40,-30,-30,-30,-30,-40,-50
    ],

    'B': [
        -20, -10, -10, -10, -10, -10, -10, -20,
        -10, 0, 0, 0, 0, 0, 0, -10,
        -10, 0, 5, 10, 10, 5, 0, -10,
        -10, 5, 5, 10, 10, 5, 5, -10,
        -10, 0, 10, 10, 10, 10, 0, -10,
        -10, 10, 10, 10, 10, 10, 10, -10,
        -10, 5, 0, 0, 0, 0, 5, -10,
        -20, -10, -10, -10, -10, -10, -10, -20
    ],

    'R': [
        5, 7.5, 10, 10, 10, 10, 7.5, 5,
        -20, 5, 5, 5, 5, 5, 5, -20,
        -50, 0, 0, 0, 0, 0, 0, -50,
        -50, 0, 0, 0, 0, 0, 0, -50,
        -50, 0, 0, 0, 0, 0, 0, -50,
        -50 , 0 , 0 , 0 , 0 , 0 , 0 , -50,
        -50 , -5 , -5 , -5 , -5 , -5 , -5 , -50,
        -20 ,-20,-10 ,-5 ,-5 ,-10 ,-10 ,-20
    ],

    'Q': [
        -20, -10, -10, -5, -5, -10, -10, -20,
        -10, 0, 0, 0, 0, 0, 0, -10,
        -10, 0, 5, 5, 5, 5, 0, -10,
        -5 , 0 , 5 , 5 , 5 , 5 , 0 , -5,
        0 , 0 , 5 , 5 , 5 , 5 , 0 , -10,
        -10 , 5 , 5 , 5 , 5 , 5 , 0 ,-10,
        -10 , 0 , 5 , 0 , 0 , 0 , 0 ,-10,
        -20 ,-10 ,-10 ,-5 ,-5 ,-10 ,-10 ,-20
    ],

    'K': [
        -30, -40, -40, -50, -50, -40, -40, -30,
        -30, -40, -40, -50, -50, -40, -40, -30,
        -30, -40, -40, -50, -50, -40, -40, -30,
        -30 , 0 , 0 , 0 , 0 , 0 , 0 , -30,
        -20 , 20 , 20 , 20 , 20 , 20 , 20 ,-20,
        -10 ,-20 ,-20 ,-20 ,-20 ,-20 ,-20 ,-10,
        20 , 20 , 0 , 0 , 0 , 0 , 20 , 20,
        20 , 30 , 10 , 0 , 0 , 10 , 30 , 20
     ]
}

#SURTOUT POUR L'EARLY GAME, IL FAUDRA UTILISER UN COEFFCIENT QUI SE REDUIT AU FUR ET A MESURE

VALEURS_POSITIONS_NOIR = {
    'p': VALEURS_POSITIONS_BLANCHES['P'][::-1],
    'n': VALEURS_POSITIONS_BLANCHES['N'][::-1],
    'b': VALEURS_POSITIONS_BLANCHES['B'][::-1],
    'r': VALEURS_POSITIONS_BLANCHES['R'][::-1],
    'q': VALEURS_POSITIONS_BLANCHES['Q'][::-1],
    'k': VALEURS_POSITIONS_BLANCHES['K'][::-1]
}

def evaluation (board):
    """
    Évalue la position du plateau et retourne un score.
    Un score positif indique un avantage pour les blancs, tandis qu'un score négatif indique un avantage pour les noirs.
    L'évaluation prend en compte la valeur des pièces et leur position sur le plateau.
    On va utiliser cette évaluation avec l'algorithme mini-max pour que notre IA puisse choisir le meilleur coup à jouer.
    """
    score = 0

    if board.is_checkmate():   
        return -float('inf') if board.turn else float('inf')
    if board.is_stalemate() or board.is_insufficient_material():
        return 0
        
    for square in chess.SQUARES:
        piece = board.piece_at(square)
        if piece is not None:
            piece_value = VALEURS_PIECES[piece.symbol().lower()]
            if piece.color == chess.WHITE:
                score += piece_value + VALEURS_POSITIONS_BLANCHES[piece.symbol()][square]
            else:
                score -= piece_value + VALEURS_POSITIONS_NOIR[piece.symbol()][square]
    return score

def mini_max (board, profondeur, player, maximizing: bool):
    """
    Ce truc ne ne sert à rien mais nous aidera pour construire l'algorithme alpha-beta
    """

    if profondeur == 0:
        return evaluation (board)
    else:
        best_score = -float('inf') if maximizing else float('inf')
        best_move = None
        for move in board.legal_moves():
            board.push(move)
            score = mini_max(board, profondeur - 1)
            board.pop()
            if maximizing:
                best_score = max(best_score, score)
                best_move = move
            else:
                best_score = min(best_score, score)
                best_move = move
        return best_score, best_move

def alpha_beta (board, profondeur:int , alpha: float = -float('inf'), beta: float = float('inf'), maximizing: bool = True) -> float:
    """
    Ordre:
    - Regarde la mémoire pour voir si la position a déjà été évaluée
        - Si oui, retourne l'évaluation
    - Si non, évalue la position (avec mini_max)
    """

    if profondeur == 0 or board.is_game_over():
        return evaluation (board)
    
    if maximizing: 
        score = -float('inf')
        for move in board.legal_moves:
            board.push(move)
            score, best_move = alpha_beta(board, profondeur - 1, alpha, beta, False)
            board.pop()
            alpha = max(alpha, score)

            if alpha == score: #si c'est égal, on peut aussi stocker le move pour faire du move ordering
                best_move = move
            
            if alpha >= beta: #il gagne, pas besoin de continuer à chercher
                break

    else:
        score = float('inf')
        for move in board.legal_moves:
            board.push(move)
            score, best_move = alpha_beta(board, profondeur - 1, alpha, beta, True)
            board.pop()
            beta = min(beta, score)
            
            if beta == score: #si c'est égal, on peut aussi stocker le move pour faire du move ordering
                best_move = move
            
            if alpha >= beta: 
                break
        
    return score, best_move

if __name__ == "__main__":
    board = chess.Board()
