import os
import json
import random
import chess

# ======================
# CONFIG
# ======================
SEARCH_DEPTH = 4
MEMOIRE_FILE = "memoire.json"

PIECE_VALUES = {
    chess.PAWN: 100,
    chess.KNIGHT: 320,
    chess.BISHOP: 330,
    chess.ROOK: 500,
    chess.QUEEN: 900,
    chess.KING: 20000
}

CENTER_SQUARES = {chess.D4, chess.E4, chess.D5, chess.E5}

# ======================
# ZOBRIST (STABLE)
# ======================
random.seed(2024)

def rand64():
    return random.getrandbits(64)

PIECE_SYMBOLS = ['P','N','B','R','Q','K','p','n','b','r','q','k']
Z_PIECE = {s: [rand64() for _ in range(64)] for s in PIECE_SYMBOLS}
Z_SIDE = rand64()
Z_CASTLE = {k: rand64() for k in "KQkq"}
Z_EP = [rand64() for _ in range(8)]

def compute_zobrist(board):
    h = 0
    for sq in chess.SQUARES:
        p = board.piece_at(sq)
        if p:
            h ^= Z_PIECE[p.symbol()][sq]

    if board.turn == chess.BLACK:
        h ^= Z_SIDE

    if board.has_kingside_castling_rights(chess.WHITE): h ^= Z_CASTLE['K']
    if board.has_queenside_castling_rights(chess.WHITE): h ^= Z_CASTLE['Q']
    if board.has_kingside_castling_rights(chess.BLACK): h ^= Z_CASTLE['k']
    if board.has_queenside_castling_rights(chess.BLACK): h ^= Z_CASTLE['q']

    if board.ep_square is not None:
        h ^= Z_EP[chess.square_file(board.ep_square)]

    return h

# ======================
# MÉMOIRE PERSISTANTE (PV UNIQUEMENT)
# ======================
if os.path.exists(MEMOIRE_FILE):
    try:
        with open(MEMOIRE_FILE, "r") as f:
            memoire = json.load(f)
    except:
        memoire = {}
else:
    memoire = {}

def save_memoire():
    with open(MEMOIRE_FILE, "w") as f:
        json.dump(memoire, f, indent=2)

# ======================
# ÉVALUATION
# ======================
def evaluate(board):
    if board.is_checkmate():
        return -999999 if board.turn == chess.WHITE else 999999
    if board.is_stalemate() or board.is_insufficient_material():
        return 0

    score = 0
    for sq in chess.SQUARES:
        p = board.piece_at(sq)
        if p:
            sign = 1 if p.color == chess.WHITE else -1
            score += PIECE_VALUES[p.piece_type] * sign
            if sq in CENTER_SQUARES:
                score += 15 * sign
    return score

# ======================
# TRANSPOSITION TABLE (RAM)
# ======================
TT = {}

def tt_lookup(zob, depth):
    entry = TT.get(zob)
    if entry and entry["depth"] >= depth:
        return entry
    return None

def tt_store(zob, depth, score, move):
    TT[zob] = {
        "depth": depth,
        "score": score,
        "move": move
    }

# ======================
# MINIMAX + ALPHA-BETA
# ======================
def minimax(board, depth, alpha, beta, maximizing):
    zob = compute_zobrist(board)

    entry = tt_lookup(zob, depth)
    if entry:
        return entry["score"], entry["move"]

    if depth == 0 or board.is_game_over():
        return evaluate(board), None

    best_move = None

    if maximizing:
        value = -10**9
        for move in board.legal_moves:
            board.push(move)
            score, _ = minimax(board, depth-1, alpha, beta, False)
            board.pop()

            if score > value:
                value = score
                best_move = move

            alpha = max(alpha, score)
            if alpha >= beta:
                break
    else:
        value = 10**9
        for move in board.legal_moves:
            board.push(move)
            score, _ = minimax(board, depth-1, alpha, beta, True)
            board.pop()

            if score < value:
                value = score
                best_move = move

            beta = min(beta, score)
            if alpha >= beta:
                break

    tt_store(zob, depth, value, best_move)
    return value, best_move

# ======================
# IA
# ======================
class AI:
    def __init__(self, color, depth=SEARCH_DEPTH):
        self.color = color
        self.depth = depth

    def play(self, board):
        TT.clear()  # reset par coup
        score, move = minimax(
            board,
            self.depth,
            -10**9,
            10**9,
            self.color == chess.WHITE
        )

        if move:
            zob = str(compute_zobrist(board))
            memoire[zob] = {
                "best_move": move.uci(),
                "score": score
            }
            save_memoire()

        return move

# ======================
# JEU CONSOLE
# ======================
def play_console():
    board = chess.Board()
    ai = AI(chess.BLACK)

    while not board.is_game_over():
        print("\n", board)

        if board.turn == chess.WHITE:
            uci = input("Votre coup (uci) : ").strip()
            try:
                board.push_uci(uci)
            except:
                print("Coup invalide.")
        else:
            move = ai.play(board)
            if not isinstance(move, chess.Move):
                print("IA bloquée.")
                break

            print("IA joue :", move.uci())
            board.push(move)

    print("\nRésultat :", board.result())

# ======================
# MAIN
# ======================
if __name__ == "__main__":
    play_console()
