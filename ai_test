import os
import json
import random
import chess
from PIL import Image, ImageTk
import tkinter as tk

# ----------------------
# Paramètres
# ----------------------
BOARD_IMAGE = "C:\\Users\\marti\\Downloads\\ChessTerm-wip-visualization\\img\\plateau.png"
PIECES_DIR = "C:\\Users\\marti\\Downloads\\ChessTerm-wip-visualization\\img"
SQUARE_SIZE = 60
OUTPUT_DIR = "boards"
GIF_FILE = "match_vs_human.gif"
MEMOIRE_FILE = "memoire.json"
os.makedirs(OUTPUT_DIR, exist_ok=True)

PIECE_IMAGES = {
    'P': "pion_blanc.png", 'N': "cavalier_blanc.png", 'B': "fou_blanc.png",
    'R': "tour_blanche.png", 'Q': "reine_blanche.png", 'K': "roi_blanc.png",
    'p': "pion_noir.png", 'n': "cavalier_noir.png", 'b': "fou_noir.png",
    'r': "tour_noire.png", 'q': "reine_noire.png", 'k': "roi_noir.png",
}

pieces_images = {}
for k, fname in PIECE_IMAGES.items():
    path = os.path.join(PIECES_DIR, fname)
    pieces_images[k] = Image.open(path).convert("RGBA").resize(
        (SQUARE_SIZE, SQUARE_SIZE),
        Image.Resampling.LANCZOS
    )

board_img = Image.open(BOARD_IMAGE).convert("RGBA").resize(
    (SQUARE_SIZE*8, SQUARE_SIZE*8),
    Image.Resampling.LANCZOS
)

PIECE_VALUES = {chess.PAWN:100, chess.KNIGHT:320, chess.BISHOP:330,
                chess.ROOK:500, chess.QUEEN:900, chess.KING:20000}

CENTER_SQUARES = [chess.D4, chess.E4, chess.D5, chess.E5]

# ----------------------
# Mémoire
# ----------------------
if os.path.exists(MEMOIRE_FILE):
    try:
        with open(MEMOIRE_FILE, "r") as f:
            memoire = json.load(f)
    except json.JSONDecodeError:
        print("Mémoire corrompue. Nouvelle mémoire créée.")
        memoire = {}
else:
    memoire = {}

def save_memoire():
    with open(MEMOIRE_FILE, "w") as f:
        json.dump(memoire, f, indent=2)

def update_memory(fen, move, eval_score):
    uci = move.uci()
    if fen not in memoire:
        memoire[fen] = {"moves": {}}
    if "moves" not in memoire[fen]:
        memoire[fen]["moves"] = {}
    if uci not in memoire[fen]["moves"]:
        memoire[fen]["moves"][uci] = []
    memoire[fen]["moves"][uci].append(eval_score)

# ----------------------
# Evaluation simple
# ----------------------
def evaluate_board(board):
    if board.is_checkmate():
        return -999999 if board.turn else 999999
    if board.is_stalemate() or board.is_insufficient_material() or board.can_claim_fifty_moves():
        return 0

    score = 0
    for sq in chess.SQUARES:
        piece = board.piece_at(sq)
        if piece:
            value = PIECE_VALUES[piece.piece_type]
            sign = 1 if piece.color == chess.WHITE else -1
            score += sign * value
            if sq in CENTER_SQUARES:
                score += 15 * sign

    mobility = len(list(board.legal_moves))
    score += (mobility*2 if board.turn == chess.WHITE else -mobility*2)

    for color in [chess.WHITE, chess.BLACK]:
        king_sq = board.king(color)
        if king_sq is not None:
            if board.is_check():
                score += -200 if color == chess.WHITE else 200
            rank = chess.square_rank(king_sq)
            if color == chess.WHITE and rank == 0:
                score += 40
            if color == chess.BLACK and rank == 7:
                score -= 40
    return score

# ----------------------
# Minimax alpha-beta avec mémoire
# ----------------------
def minimax(board, depth, alpha, beta, maximizing, ignore_memory=False):
    fen = board.board_fen()
    if not ignore_memory and fen in memoire and "moves" in memoire[fen] and memoire[fen]["moves"]:
        moves_data = memoire[fen]["moves"]
        best_uci = max(moves_data, key=lambda m: sum(moves_data[m])/len(moves_data[m]))
        best_move = chess.Move.from_uci(best_uci)
        best_score = sum(moves_data[best_uci])/len(moves_data[best_uci])
        best_score += random.uniform(-0.1, 0.1)
        return best_score, best_move

    if depth == 0 or board.is_game_over():
        return evaluate_board(board), None

    moves = list(board.legal_moves)
    moves.sort(key=lambda m: 0 if board.is_capture(m) else 1)

    best_move = None
    if maximizing:
        max_eval = -10**9
        for move in moves:
            board.push(move)
            eval_score, _ = minimax(board, depth-1, alpha, beta, False, ignore_memory)
            board.pop()
            if eval_score > max_eval:
                max_eval = eval_score
                best_move = move
            alpha = max(alpha, eval_score)
            if alpha >= beta:
                break
        if best_move:
            update_memory(fen, best_move, max_eval)
        return max_eval, best_move
    else:
        min_eval = 10**9
        for move in moves:
            board.push(move)
            eval_score, _ = minimax(board, depth-1, alpha, beta, True, ignore_memory)
            board.pop()
            if eval_score < min_eval:
                min_eval = eval_score
                best_move = move
            beta = min(beta, eval_score)
            if alpha >= beta:
                break
        if best_move:
            update_memory(fen, best_move, min_eval)
        return min_eval, best_move

# ----------------------
# Bot évolutif
# ----------------------
class EvolvingBot:
    def __init__(self,color,start_depth=3,growth_rate=6,max_depth=5,name="Bot"):
        self.color=color
        self.depth=start_depth
        self.start_depth=start_depth
        self.growth_rate=growth_rate
        self.max_depth=max_depth
        self.name=name
        self.ply_count=0

    def maybe_evolve(self):
        new_depth = min(self.max_depth, self.start_depth + self.ply_count // self.growth_rate)
        if new_depth != self.depth:
            print(f"{self.name} évolue : {self.depth} -> {new_depth}")
            self.depth = new_depth

    def select_move(self, board):
        self.ply_count += 1
        self.maybe_evolve()
        ignore_memory = board.fullmove_number < 5
        score, move = minimax(board, self.depth, -10**9, 10**9, self.color==chess.WHITE, ignore_memory)
        score += random.uniform(-0.1,0.1)
        if random.random() < 0.2:
            legal_moves = list(board.legal_moves)
            return random.choice(legal_moves)
        if move is None:
            moves = list(board.legal_moves)
            return random.choice(moves) if moves else None
        return move

# ----------------------
# Dessin plateau
# ----------------------
def draw_board_with_pieces(board):
    img = board_img.copy()
    for sq in chess.SQUARES:
        piece = board.piece_at(sq)
        if piece:
            file = chess.square_file(sq)
            rank = 7 - chess.square_rank(sq)
            x = file*SQUARE_SIZE
            y = rank*SQUARE_SIZE
            img.paste(pieces_images[piece.symbol()],(x,y),pieces_images[piece.symbol()])
    return img

# ----------------------
# Partie GUI : Humain vs IA
# ----------------------
def play_game_gui_human_vs_ai(max_moves=60, delay=500):
    board = chess.Board()
    frames = []
    move_number = 0

    human_color = random.choice([chess.WHITE, chess.BLACK])
    ai_color = not human_color
    bot_ai = EvolvingBot(ai_color, start_depth=3, growth_rate=5, max_depth=4, name="Alpha")
    print("Vous jouez les", "Blancs" if human_color==chess.WHITE else "Noirs")

    root = tk.Tk()
    root.title("Échiquier Humain vs IA")
    canvas = tk.Label(root)
    canvas.pack()

    img = draw_board_with_pieces(board)
    tk_img = ImageTk.PhotoImage(img)
    canvas.config(image=tk_img)
    canvas.image = tk_img

    selected_square = None

    def update_board():
        nonlocal move_number
        move_number += 1
        img = draw_board_with_pieces(board)
        tk_img = ImageTk.PhotoImage(img)
        canvas.config(image=tk_img)
        canvas.image = tk_img
        frames.append(img)

    def on_click(event):
        nonlocal selected_square
        if board.turn != human_color:
            return
        file = event.x // SQUARE_SIZE
        rank = 7 - (event.y // SQUARE_SIZE)
        sq = chess.square(file, rank)
        if selected_square is None:
            piece = board.piece_at(sq)
            if piece is None or piece.color != human_color:
                return
            selected_square = sq
        else:
            move = chess.Move(selected_square, sq)
            if move in board.legal_moves:
                board.push(move)
                update_board()
                selected_square = None
                root.after(delay, ai_turn)
            else:
                selected_square = None

    canvas.bind("<Button-1>", on_click)

    def ai_turn():
        if board.is_game_over() or move_number >= max_moves:
            finish_game()
            return
        if board.turn == ai_color:
            move = bot_ai.select_move(board)
            if move:
                board.push(move)
                print(f"IA ({'Blancs' if ai_color==chess.WHITE else 'Noirs'}): {move}")
                update_board()
            root.after(delay, ai_turn)

    def finish_game():
        result = board.result()
        print("Partie terminée:", result)
        winner = None
        if result == "1-0":
            winner = chess.WHITE
        elif result == "0-1":
            winner = chess.BLACK

        # Renforcer la mémoire
        for fen, data in memoire.items():
            for uci, scores in data["moves"].items():
                if winner == ai_color:
                    scores.append(1)
                elif winner == human_color:
                    scores.append(-1)
                else:
                    scores.append(0)
        save_memoire()

        if frames:
            frames[0].save(GIF_FILE, save_all=True, append_images=frames[1:], duration=delay, loop=0)
            print(f"GIF enregistré : {GIF_FILE}")

    # Début automatique si l'IA est Blanc
    if board.turn == ai_color:
        root.after(0, ai_turn)

    root.mainloop()

# ----------------------
# Lancement
# ----------------------
if __name__=="__main__":
    play_game_gui_human_vs_ai(max_moves=200, delay=200)
