"""
canvas_tkinter.py
=================
Interface graphique Tkinter pour visualiser une partie d'échecs IA vs IA.

Responsabilités :
    - Afficher le plateau et les pièces via un Canvas Tkinter.
    - Faire tourner le calcul IA dans un thread secondaire pour ne pas
      geler l'interface pendant la réflexion.
    - Afficher l'historique des coups en notation SAN.
    - Afficher le résultat de la partie (mat, pat, nulle).

Dépendances :
    - Pillow (PIL) pour charger et redimensionner les images des pièces.
    - python-chess pour la logique du jeu.
    - canvas_tkinter s'appuie sur des images dans le dossier img/.

Utilisation :
    Instancier Chess_UI(root, board, joueur_blanc, joueur_noir) depuis main.py.
    Les joueurs doivent exposer une méthode coup() → str (notation SAN).
"""

from tkinter import *
from tkinter import ttk
from PIL import Image, ImageTk
from chess import *
import threading

# ── Dimensions du plateau en pixels ──────────────────────────────────────────
board_width  = 640
board_height = 640


class Chess_UI:
    """
    Interface graphique complète pour une partie d'échecs IA vs IA.

    Le calcul du coup IA est délégué à un thread daemon pour éviter de
    bloquer la boucle d'événements Tkinter pendant la réflexion.
    La communication thread → UI passe exclusivement par root.after()
    pour respecter le modèle mono-thread de Tkinter.

    Attributs
    ----------
    root : Tk
        Fenêtre racine Tkinter.
    board : chess.Board
        Plateau partagé entre l'UI et les deux joueurs IA.
    Joueur_Blanc : JoueurIA
        Instance du joueur IA qui joue les blancs.
    Joueur_Noir : JoueurIA
        Instance du joueur IA qui joue les noirs.
    canvas : Canvas
        Canvas Tkinter sur lequel le plateau et les pièces sont dessinés.
    history_text : Text
        Widget texte qui affiche l'historique des coups en notation SAN.
    status_label : Label
        Label affiché sous le plateau pour indiquer l'état du calcul.
    pieces_list : list[int]
        Identifiants des images de pièces actuellement dessinées sur le canvas
        (utilisés pour les effacer avant chaque redraw).
    _computing : bool
        Verrou logique : True quand un thread de calcul est en cours,
        pour éviter de lancer deux calculs simultanément.
    img_dict : dict[str, ImageTk.PhotoImage]
        Dictionnaire symbol_pièce → image chargée en mémoire.
    """

    def __init__(self, root, board, J_Blanc, J_Noir):
        """
        Initialise l'interface graphique et démarre la partie après 1 seconde.

        Paramètres
        ----------
        root : Tk
            Fenêtre racine Tkinter.
        board : chess.Board
            Plateau de jeu partagé.
        J_Blanc : JoueurIA
            Joueur IA pour les blancs (doit exposer coup() → str SAN).
        J_Noir : JoueurIA
            Joueur IA pour les noirs (doit exposer coup() → str SAN).
        """
        piece_size = 70
        self.img_dict = {
            'p': ImageTk.PhotoImage(Image.open('img/pion_noir.png').resize((piece_size, piece_size))),
            'b': ImageTk.PhotoImage(Image.open('img/fou_noir.png').resize((piece_size, piece_size))),
            'q': ImageTk.PhotoImage(Image.open('img/reine_noire.png').resize((piece_size, piece_size))),
            'k': ImageTk.PhotoImage(Image.open('img/roi_noir.png').resize((piece_size, piece_size))),
            'n': ImageTk.PhotoImage(Image.open('img/cavalier_noir.png').resize((piece_size, piece_size))),
            'r': ImageTk.PhotoImage(Image.open('img/tour_noire.png').resize((piece_size, piece_size))),
            'P': ImageTk.PhotoImage(Image.open('img/pion_blanc.png').resize((piece_size, piece_size))),
            'B': ImageTk.PhotoImage(Image.open('img/fou_blanc.png').resize((piece_size, piece_size))),
            'Q': ImageTk.PhotoImage(Image.open('img/reine_blanche.png').resize((piece_size, piece_size))),
            'K': ImageTk.PhotoImage(Image.open('img/roi_blanc.png').resize((piece_size, piece_size))),
            'N': ImageTk.PhotoImage(Image.open('img/cavalier_blanc.png').resize((piece_size, piece_size))),
            'R': ImageTk.PhotoImage(Image.open('img/tour_blanche.png').resize((piece_size, piece_size))),
        }

        self.root          = root
        self.board         = board
        self.Joueur_Blanc  = J_Blanc
        self.Joueur_Noir   = J_Noir
        self.mainframe     = ttk.Frame(self.root)
        self.mainframe.grid()

        self.canvas = Canvas(
            self.mainframe,
            bg="black",
            width=board_width,
            height=board_height
        )
        self.canvas.grid(row=0, column=0)

        self.bg_img   = Image.open('img/plateau.png').resize((board_width, board_height))
        self.bg_photo = ImageTk.PhotoImage(self.bg_img)
        self.canvas.create_image(board_width / 2, board_height / 2, image=self.bg_photo)

        history_frame = Frame(self.mainframe, bg="white")
        history_frame.grid(row=0, column=1, sticky=(N, S), padx=10)

        Label(history_frame, text="Historique", bg="white", font=("Arial", 12, "bold")).pack()

        self.history_text = Text(history_frame, width=20, height=35, font=("Courier", 10))
        self.history_text.pack()

        scrollbar = Scrollbar(history_frame, command=self.history_text.yview)
        scrollbar.pack(side=RIGHT, fill=Y)
        self.history_text.config(yscrollcommand=scrollbar.set)

        self.status_label = Label(
            self.mainframe,
            text="",
            font=("Arial", 11, "italic"),
            fg="blue",
            bg="white"
        )
        self.status_label.grid(row=1, column=0, columnspan=2, pady=4)

        self.pieces_list = []
        self._computing  = False
        self.update_board()

        self.root.after(1000, self.jouer)

    # ── Utilitaires de coordonnées ────────────────────────────────────────────

    def get_x_from_col(self, col: int) -> float:
        """
        Convertit un indice de colonne (0-7) en coordonnée X sur le canvas.

        Paramètres
        ----------
        col : int
            Colonne (0 = colonne a, 7 = colonne h).

        Retourne
        --------
        float
            Coordonnée X en pixels du centre de la case.
        """
        return board_width / 8 * col + board_width / 16

    def get_y_from_row(self, row: int) -> float:
        """
        Convertit un indice de rangée (0-7) en coordonnée Y sur le canvas.

        Paramètres
        ----------
        row : int
            Rangée (0 = rangée 8 côté noir, 7 = rangée 1 côté blanc).

        Retourne
        --------
        float
            Coordonnée Y en pixels du centre de la case.
        """
        return board_height / 8 * row + board_height / 16

    def display_piece(self, piece: str, col: int, row: int) -> None:
        """
        Dessine une pièce sur le canvas à la case (col, row) et enregistre
        son identifiant dans pieces_list pour pouvoir l'effacer plus tard.

        Paramètres
        ----------
        piece : str
            Symbole de la pièce ('P', 'n', 'Q', etc.).
        col : int
            Colonne de destination (0-7).
        row : int
            Rangée de destination (0-7).
        """
        self.pieces_list.append(
            self.canvas.create_image(
                self.get_x_from_col(col),
                self.get_y_from_row(row),
                image=self.img_dict[piece]
            )
        )

    def update_board(self) -> None:
        """
        Efface toutes les pièces actuellement affichées et les redessine
        d'après le FEN courant du plateau.

        Doit être appelé exclusivement depuis le thread principal Tkinter,
        car il modifie des widgets.
        """
        for piece in self.pieces_list:
            self.canvas.delete(piece)
        self.pieces_list = []

        row = 0
        col = 0
        for piece in self.board.board_fen():
            if '1' <= piece <= '8':
                col += ord(piece) - ord('0')
            elif piece == '/':
                col = 0
                row += 1
            else:
                self.display_piece(piece, col, row)
                col += 1

        self.root.update_idletasks()

    def add_to_history(self, coup: str, is_white: bool) -> None:
        """
        Ajoute un coup à l'historique textuel.

        Les coups blancs sont écrits avec leur numéro de coup sur la même
        ligne ; le coup noir est ajouté à la suite, suivi d'un saut de ligne.

        Paramètres
        ----------
        coup : str
            Coup en notation SAN (ex. 'e4', 'Nf3', 'O-O').
        is_white : bool
            True si le coup vient des blancs, False pour les noirs.
        """
        if is_white:
            self.history_text.insert(END, f"{self.board.fullmove_number}. {coup}  ")
        else:
            self.history_text.insert(END, f"{coup}\n")
        self.history_text.see(END)

    # ── Logique de jeu ────────────────────────────────────────────────────────

    def jouer(self) -> None:
        """
        Point d'entrée pour chaque coup de la partie.

        Vérifie d'abord si la partie est terminée (affiche le résultat le
        cas échéant), puis lance le calcul IA dans un thread daemon via
        _calcul_coup(). Le verrou _computing empêche deux lancements simultanés.
        """
        if self._computing:
            return

        if self.board.is_game_over():
            res = self.board.result()
            if res == "1-0":
                res = "Blancs gagnent !"
            elif res == "0-1":
                res = "Noirs gagnent !"
            else:
                res = "Égalité !"

            self.canvas.create_rectangle(120, 270, 520, 370, fill="white", outline="red", width=4)
            self.canvas.create_text(
                320, 320,
                text=f"Partie terminée\n{res}",
                font=("Arial", 24, "bold"),
                fill="red"
            )
            self.status_label.config(text="")
            return

        self._computing = True
        thread = threading.Thread(target=self._calcul_coup, daemon=True)
        thread.start()

    def _calcul_coup(self) -> None:
        """
        Exécuté dans un thread secondaire (daemon).

        Appelle coup() sur le joueur dont c'est le tour, puis repasse
        le résultat au thread principal via root.after(0, ...) pour que
        l'application du coup et la mise à jour de l'UI soient thread-safe.

        En cas d'exception, libère le verrou _computing et affiche la
        trace complète dans la console.
        """
        try:
            if self.board.turn == WHITE:
                coup     = self.Joueur_Blanc.coup()
                is_white = True
                print(f"Blancs : {coup}")
            else:
                coup     = self.Joueur_Noir.coup()
                is_white = False
                print(f"Noirs : {coup}")

            self.root.after(0, lambda: self._appliquer_coup(coup, is_white))

        except Exception:
            import traceback
            traceback.print_exc()
            self._computing = False

    def _appliquer_coup(self, coup: str, is_white: bool) -> None:
        """
        Appelé depuis le thread principal après que _calcul_coup a terminé.

        Enregistre le coup dans l'historique, l'applique sur le plateau
        python-chess, met à jour l'affichage visuel, libère le verrou
        _computing, puis planifie le prochain coup dans 300 ms.

        Paramètres
        ----------
        coup : str
            Coup en notation SAN à appliquer.
        is_white : bool
            True si le coup vient des blancs.
        """
        try:
            self.add_to_history(coup, is_white)
            self.board.push_san(coup)
            self.update_board()
        except Exception as e:
            print(f"Erreur lors de l'application du coup '{coup}': {e}")
            import traceback
            traceback.print_exc()
        finally:
            self._computing = False
            self.status_label.config(text="")
            self.root.after(300, self.jouer)
